# Этапы компиляции

Стадии компиляции кода:
1. Препроцессинг
2. Транслирование (Компиляция)
3. Ассемблирование
4. Линковка

- Рассмотрим каждый из этапов компиляции.
- В рабочей директории создадим файл `hello.cpp` со следующим содержимым:

```cpp
#include <iostream>

int main() {
	int x;
	
	std::cin >> x;
	std::cout << x + 5;
}
```

## Препроцессинг
- Этакая подготовка C++ кода к "настоящей" компиляции
- cpp -> cpp

- **Препроцессором выполняются следующие действия:**
	- Замена соответствующих диграфов и триграфов на эквивалентные символы «`#`» и «`\`»
	- Удаление экранированных символов перевода строки
	- Замена строчных и блочных комментариев пустыми строками (с удалением окружающих пробелов и символов табуляции)
	- Вставка (включение) содержимого произвольного файла (`#include`)
	- Макроподстановки (`#define`)
	- Условная компиляция (`#if`, `#ifdef`, `#elif`, `#else`, `#endif`)
	- Вывод сообщений (`#warning`, `#error`)

#### Выполнение только стадии препроцессора
```bash
g++ -E -v hello.cpp > hello.e
```

- Узнаем количество строк в файле (будет >30'000 строк)
```bash
wc -l hello.e
```
- [[Programs#wc]]

- Заметим, что даже после подстановки всех header'ов все упоминания`std::cin` и `std::cout` - это лишь объявления через `extern`. Сами они нигде пока не определены.

## Трансляция
- Она же - компиляция
- Перевод кода в ассемблер - язык процессорных инструкций
	- cpp -> asm
- Осуществляется манглирование имен, инстанцирование шаблонов, рассахаривание ООП и многого другого

```bash
g++ -S hello.cpp > hello.s
```
- Здесь всего 18 строк

## Ассемблирование
- Перевод ассемблера в бинарный формат
	- Самая легкая операция - просто перевод человеко-языка в бинарный формат

```bash
g++ -c hello.s
```
- Out: `hello.o`
- Прочитать невозможно

- Расшифровать "бинарь" в последовательность 16-тиричных символов и, по возможности, экранизированные названия сущностей
```bash
hexdump -C hello.o
```
- [[Programs#hexdump]]

- Посмотреть assembler
	- Это  из `bin utils`
```bash
objdump -D hello.o
```

## Линковка
- Необходима, даже если всего 1 cpp'шник. Он присоединяет к написанному коду стандарные сущности (`std::cin`, `std::cout`, `malloc`, `new`, ...)
- В коде `hello.o` (если посмотреть, скажем, через `hexdump`) лежат латинские названия функций, которые необходимо найти и присоединить
	- Для точного распознавания и исключения коллизии как раз и необходимо манглирование имен
	- Если посмотреть на ассемблер `hello.o`, то адреса функций, которые вызываются в этом файле, но здесь не определены, будут пустыми (zero)

- После линковки содержимое файла значительно возрастает, а адреса вызовов функций заменяются на нормальные.

==TODO== отличия .o от .out - скомпиленный от бинарника 
