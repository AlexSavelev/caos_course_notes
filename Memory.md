Виртуальная память и управление памятью в Linux

# 1. Концепция виртуальной памяти
Когда мы обращаемся к памяти через указатель, мы обращаемся не напрямую, а посредством ОС, давая ей виртуальный адрес. У такого подхода есть ряд преимуществ:
- Независимость процессов
- Сегментирование. Можем запросить память под массив из `100'000` `int`'ов, а физически не может оказаться непрерывного отрезка необходимой размерности. А виртуально все можно организовать!
- Можно писать в файлы под видом ОЗУ (как пример, `/swapfile')`
- Приаттачивать (маппить) адреса уже загруженных динамических библиотек
А в это время ОС дает иллюзию того, что адресное пространство непрерывно и т.д.

Виртуальная память — это абстракция, предоставляемая ОС, которая позволяет процессам работать с памятью как с непрерывным адресным пространством, независимо от реального расположения данных в физической памяти. Преимущества: изоляция процессов, возможность выделять виртуально непрерывные блоки даже при фрагментированной физической памяти, своппинг, отображение файлов и библиотек.

![[virtual_memory.png|300]]

# 2. `maps` — карта памяти процесса

Пример:
```cpp
#include <iostream>

int main() {
	getchar();
}
```

```bash
pgrep a.out
cd /proc/{PID}
cat maps
```

`maps` — карта памяти процесса — содержит информацию об адресах памяти, выделенных под тот или иной сегмент.

Если присмотреться внимательнее, заметим много записей `a.out` — это сегменты, и у каждого свои права.
- **.text (r-x):** код программы
- **.data (rw-):** инициализированные глобальные/статические переменные
- **.rodata (r--):** read-only данные (строковые литералы, константы)
- **.bss (rw-):** неинициализированные глобальные/статические переменные (в файле занимает 0 байт, занимает место только в виртуальной памяти при загрузке)
- **heap:** динамическая память, управляемая через `malloc`/`brk`
- **stack:** стек

# 3. MMU и таблицы страниц
Это о том, как работает процесс обращения к памяти.
В процессоре есть MMU (Memory Management Unit)
- То есть процессор сам, на уровне железа, поддерживает преобразование виртуальных и физических адресов.

## 3.1 Таблицы страниц (Page Tables)
Когда обращаемся к виртуальному адресу, обращаемся в MMU. Есть огромная map'ка процесса, которая по виртуальному адресу определяет физический.

Как эта map'а устроена? Если хранить отображение каждого байта, то она, ясное дело, будет объемной. Поэтому она хранит отображение именно что страниц (page). Поэтому таблица называется **page table**.
Как правило размер страницы - 4Kb
- Если посмотреть на `/proc/.../maps`, то там везде в адресах последние `000` ($16^3 = 4096$ => 4Kb)
Но по объему это все равно достаточно много. Поэтому в современных ОС (как минимум с 2004 года) отображения составляют многоуровневые деревья.
В процессоре есть отдельный регистр с физическим адресом таблицы страниц. При разыменовании процессор знает, куда идти. При context switch'е адреса подменяются.
- **Комментарий:** В x86-64 используется 4-уровневая таблица страниц. При контекстном переключении ОС загружает физический адрес корневой таблицы в регистр `CR3`.

Подробнее о page tables: [Linux Kernel Documentation](https://docs.kernel.org/mm/page_tables.html)
Объяснение многоуровневых таблиц: [LWN.net](https://lwn.net/articles/106177/)

# 4. TLB (Translation Lookaside Buffer)
Все этого весело, но долго. Поэтому есть кэши.
**TLB** — это аппаратный кэш внутри процессора для ускорения преобразования виртуальных адресов в физические.

**Обращение к памяти:**
1. CPU выдаёт виртуальный адрес
2. Проверяется TLB (hit → физический адрес, miss → продолжение)
3. Обращение к таблице страниц через MMU
4. Если страница отсутствует или нарушены права → Page Fault
5. ОС обрабатывает fault (выделяет память, загружает с диска, убивает процесс)
6. Повтор попытки доступа

![[tlb.png|600]]

**Можно померить, сколько было TLB Hit & TLB Miss'ов:**
```bash
sudo perf stat -e dTLB-loads,dTLB-load-misses,iTLB-loads,iTLB-load-misses -p $(pgrep a.out) --sleep 2
```
- `iTLB` - instruction TLB

Можно посмотреть, сколько было запросов, когда:
1) Создается вектор размера `100'000`
2) Создается список размера `100'000`
При последовательном доступе к элементам вектора (contiguous memory) будет меньше TLB-промахов, чем при обходе связного списка (random access).
- При последовательном обходе вектора (contiguous memory) высока **пространственная локальность**. Соседние элементы, скорее всего, лежат на одной или смежных страницах памяти. После первого обращения к странице её трансляция попадает в TLB, и последующие обращения к элементам на этой же странице будут **TLB-hit**.
- При обходе связного списка (random access) элементы разбросаны по памяти, и обращение к каждому новому элементу с высокой вероятностью потребует обращения к новой странице, что приводит к **TLB-miss** и дорогостоящему обращению к таблице страниц.

# 5. Page Faults
**Page Fault** — исключение, возникающее при обращении к виртуальной странице, которая:
- Не отображена на физическую память (но разрешена)
- Запрещена для доступа (например, попытка записи в read-only страницу)

Segmentation Fault возникает при попытке доступа к запрещённой странице (например, обращение к `NULL`, нарушение прав `r/w/x` или обращение к ядру из userspace).
Если просто память "зарегистрирована", но не выделена, то ОС ищет место в памяти, чтобы поставить в соответствие физический адрес

**Можно померить количество page fault'ов:**
```bash
sudo perf stat -e page-faults -p $(pgrep a.out) --sleep 2
```

Все Page Faults делятся на minor и major
- minor — выделяет память, перестраивает дерево...
- major — обращение к файлу. Да, major page fault возникает, когда страница отсутствует в ОЗУ и должна быть загружена с диска.
	- Например, если данные в ОЗУ не использованы 2 дня, то ОС может загрузить во временный файл
	- Например, из swap-файла

# 6. Системные вызовы для работы с памятью

## 6.1 `mmap` и `munmap`
`mmap` — запрашиваем память
`mummap` — освобождает память

```cpp
#include <sys/mman.h>

void *mmap(void addr[.length], size_t length, int prot, int flags, int fd, off_t offset);

int munmap(void addr[.length], size_t length);
```

```cpp
#include <iostream>
#include <sys/mman.h>

int main() {
	getchar();

	char* ptr = mmap(NULL, 1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
	
	std::cout << (void*)ptr << '\n';
	getchar();
	
	for (int i = 0; i < 1000; ++i) {
		*(ptr + i) = 'a';
	}
	
	munmap(ptr, 1000);
	return 0;
}
```

Можем запускаться, смотреть состояние файла `mmap`

`mmap` выделяет страницами. **Здесь segfault будет на 4096'м шаге:**
```cpp
for (int i = 0; i < 5000; ++i) {
	std::cout << i << std::endl;
	*(ptr + i) = 'a';
}
```

**Замечание:**
Если выделить 3 страницы (например, 10'000 байт) и вызвать `munmap(1000)`, то это UB. Но скорее всего, за-анмапится ровно 1 страница (то есть нам останется меньше, чем ожидалось).

Если убрать `PROT_WRITE`, то будет Segmentation Fault.
- На самом деле, в таблицах, TLB и прочем также есть флаги на `r/w/x`
- И на этапе обращения проверяются и права

Могу написать адрес, на котором хочется выделить память
- Но если адрес занят или не выровнен — `MAP_FAILED` — `(void*)(-1)`.
```cpp
char* ptr = mmap(0x60000000, 1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
```

## 6.2 `mremap`
Есть еще функция `mremap`. Расширяет/сужает выделенную память

**Пример:**
```cpp
void* ptr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
ptr = mremap(ptr, 4096, 8192, MREMAP_MAYMOVE); // расширяем до 8K
```

## 6.3 `brk` и `sbrk`
Как устроен `malloc`. Если работаем с маленькими объемами данных (малые аллокации), то аллоцирует на heap'е и используется `brk` (`man 2 brk`). Если объемы большие, то аллоцирует через `mmap`

`brk` - `program break` - конец program-сегмента
- Это указатель на конец `heap`'а
- Когда вызываем `brk`, конец сегмента сдвигается

```cpp
#include <unistd.h>

int brk(void *addr);
void *sbrk(intptr_t increment);
```

**Пример:**
```cpp
std::vector<int> a;
for (int i = 0; i < 100'000'000; ++i) {
	a.push_back(1);
	if (i & (i - 1) == 0) {
		std::cout << i << ' ' << a.data() << '\n';
	}
}
```
- Начиная с какого-то индекса, значения адресов заметно поменяются. Это и будет означать, что вектор "переехал с кучи".

## 6.4 `mprotect`
`mprotect` - изменить права на уже выделенную память.

**Права:** `PROT_READ`, `PROT_WRITE`, `PROT_EXEC`

**Пример:**
```cpp
mprotect(ptr, size, PROT_READ); // запрещаем запись
```

`mprotect` требует выравнивания по границе страницы (обычно 4 KiB) и может привести к неопределённому поведению, если причина ошибки не в правах доступа к памяти.

# 7. Работа с файлами через `mmap`

`mmap` может использоваться для загрузки файлов в оперативную память

**Содержимое `example.txt`:**
```txt
Hello.
```

**Загружаем файл в ОЗУ:**
```cpp
int fd = open("example.txt", O_RDWR);

struct stat sb;
fstat(fd, &sb);

// MAP_SHARED. With MAP_PRIVATE there is no change in file
char* data = (char*)mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

std::cout << (void*)data << '\n';
getchar();

data[0] = 'X';

// msync() flushes changes made to the in-core copy of a file that was mapped into memory using mmap(2) back to the filesystem.
// With‐out use of this call, there is no guarantee that changes are written back before munmap(2) is called.
// See: man 2 msync
msync(data, sb.st_size, MS_SYNC);

munmap(data, sb.st_size);
```

Если откроем `maps`, увидим, что какой-то отрезок памяти спроекцирован на `example.txt`

Разница между `MAP_SHARED` и `MAP_PRIVATE`:
- `MAP_SHARED`: изменения видны другим процессам, отображающим тот же файл, и записываются на диск
- `MAP_PRIVATE`: создаётся private copy-on-write отображение; изменения не видны другим и не пишутся в файл

Т.е. при `MAP_SHARED` изменения записываются в файл. При `MAP_PRIVATE` — создаётся копия.

**msync:** Для принудительной синхронизации изменений с диском:
```cpp
msync(data, size, MS_SYNC);
```
> `msync()` flushes changes made to the in-core copy of a file that was mapped into memory using `mmap(2)` back to the filesystem.
>  With‐out use of this call, there is no guarantee that changes are written back before `munmap(2)` is called.
> See: `man 2 msync`

# 8. Динамические библиотеки и выполнение кода
## 8.1 Загрузка библиотеки
- Можно ли в runtime загрузить динамическую библиотеку и воспользоваться ею?

**`func.c`:**
```c
double sqr(double x) {
	return x * x;
}
```

```bash
g++ -c func.c
readelf -a func.o  # get .text offset
objdump -d func.o  # get info about .text functions
```

**`mmap_dynlib.c`:**
```cpp
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

// Mapping of dynamic library into memory in runtime

int main(int argc, char *argv[]) {
    const char *file_name = argv[1];
    double argument = strtod(argv[2], NULL);

    int fd = open(file_name, O_RDONLY);
    struct stat st = {};
    fstat(fd, &st);

    void *addr =
        mmap(NULL, st.st_size, PROT_READ | PROT_EXEC, MAP_PRIVATE, fd, 0);
    double (*func)(double) = (double (*)(double))((char *)addr + 0x40);  // секция .TEXT начинается с 40-го байта

    close(fd);
    double result = func(argument);
    printf("func(%f) = %f\n", argument, result);
    munmap(addr, st.st_size);
}
```

### 8.1.1 Другой пример
```cpp
#include <vector>
#include <list>
#include <iostream>
#include <sys/mman.h>
#include <errno.h>

int main() {
	std::vector<char> v;
	for (int i = 0; i < 1000000; ++i) {
		v.push_back(i);
	}
	
	std::cout << "vector starts at <<<< (int*)&v[0] << std::endl;
	std::cout << mprotect(&v[0] - 16, 10000, PROT_READ|PROT_WRITE |PROT_EXEC) << std::endl;
	getchar();
	
	v[0] = 0x33;
	void (*f)() = (void(*)()) &v[0];
	f();
}
```

- Строка 19 нужна, чтобы не было Segmentation Fault
- С 19 строкой будет Illegal instruction ($\in$ RE)

### 8.1.2 Использование dlopen/dlsym (практический способ)
```cpp
#include <dlfcn.h>
#include <iostream>

int main() {
    void* lib = dlopen("./libfunc.so", RTLD_LAZY);
    if (!lib) {
        std::cerr << dlerror() << std::endl;
        return 1;
    }
    
    auto sqr = (double(*)(double))dlsym(lib, "sqr");
    if (!sqr) {
        std::cerr << dlerror() << std::endl;
        return 1;
    }
    
    std::cout << sqr(2.0) << std::endl;
    dlclose(lib);
    return 0;
}
```

### 8.1.3 Ручная загрузка через mmap (образовательный пример)
```cpp
// Пример загрузки и выполнения кода вручную
#include <sys/mman.h>
#include <iostream>

int main() {
    // 1. Прочитать бинарный файл с кодом
    // 2. Найти .text секцию через ELF-заголовки
    // 3. Выделить память с PROT_EXEC
    // 4. Скопировать код
    // 5. Вызвать функцию
    
    // Важно: на современных системах может потребоваться отключение DEP/ASLR
    // для учебных целей
}
```

**Комментарий:** Ошибка `Illegal instruction` возникает при попытке выполнения некорректного машинного кода (например, если `mmap` не дал права `PROT_EXEC`).

**Загрузка кода из библиотеки:**
1. `mmap` с `PROT_READ|PROT_EXEC`
2. Копирование кода
3. Вызов через указатель на функцию

**Illegal Instruction:** Возникает при выполнении некорректного машинного кода или кода без `PROT_EXEC`.

**Пример ошибки:**
```cpp
void* ptr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
// Записываем мусор
memset(ptr, 0xCC, 4096); // 0xCC = int3 (breakpoint)
// Пытаемся выполнить
((void(*)())ptr)(); // Illegal instruction или Segmentation fault
```

**Важное предупреждение про DEP (Data Execution Prevention) / W^X и ASLR.**
В современных системах по умолчанию запрещено исполнение кода из области, помеченной одновременно как `PROT_WRITE` и `PROT_EXEC` (политика W^X).
Также из-за ASLR (Address Space Layout Randomization) заранее неизвестен адрес, по которому можно безопасно сделать `mmap` с фиксированным адресом.

# 9. Внутреннее устройство `malloc`/`free`

**Общая схема работы `malloc`:**
```
malloc(size)
    │
    ├── Если size < порог (обычно 128K) → использовать brk (куча)
    │       ├── Поиск в free-листах (buckets)
    │       ├── Если нет свободного → расширить кучу через brk
    │       └── Разделить большой чанк при необходимости
    │
    └── Если size >= порог → использовать mmap (анонимное отображение)
            ├── Выделить целое число страниц
            └── При освобождении — сразу munmap
```

`mmap` оперирует страницами (хотим выделить память под `int` — выделяем 4 Кб). Так что `malloc` решает задачу оптимизации малых выделений (сисколлы очень затратны по времени), и вопрос хранения размера выделенной памяти (мы не указываем размер при высвобождении).
Также `malloc` управляет ошибками (double free - это проказа не ОС, а функции `free`, которая задетектила попытку двойного высвобождения)

Дальнейшее описание бакетов и размеров чанков относится к конкретной реализации `malloc` в glibc. Другие аллокаторы (например, `jemalloc`, `tcmalloc`) устроены иначе.

## 9.1 Бакеты (buckets)
Во-первых, нужны бакеты. У нас может быть множество выделений разных размеров, возможно очень малых

- Чанки шагом 8, со сдвигом 16 (т.е. размеры образуют арифметическую прогрессию). Макс. размер - 512
```
[ CHUNK_0 ][ CHUNK_1 ][ CHUNK_2 ][ CHUNK_3 ]  <----> [ CHUNK_X ]
	 16        24         32         40                   512
```

## 9.2 Структура чанка (glibc)
```
[ PREV_SIZE | SIZE | ... USER DATA ... | FD | BK ]
```
- **SIZE:** размер чанка (включая метаданные), выровненный по 8/16 байт
- **FD/BK:** указатели для связного списка свободных чанков (ТОЛЬКО если чанк свободен)
- **USER DATA:** начало данных, возвращаемое пользователю

Важно отметить, что `PREV_SIZE` находится в конце предыдущего чанка (если он свободен), что позволяет осуществлять слияние назад. А представление выше, что можно видеть везде, является лишь классической иллюстрацией.

## 9.3 Fastbins
- **Fastbins:** односвязные списки для очень мелких освобождённых чанков (не сразу сливаются для ускорения повторных аллокаций)
## 9.4 Слияние свободных чанков
- При освобождении `free` проверяет соседние чанки — если они свободны, происходит слияние в один большой свободный блок.
