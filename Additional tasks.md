# Lecture 1
  > [!done] 
>  1. Научиться линковать hello.o вручную c помощью стандартного линковщика ld и получать исполняемый файл. Этот файл должен запускаться (и может падать с ошибкой segfault, это нестрашно), но этап линковки должен проходить успешно. Доп вопрос: разобраться, почему несмотря на успешную линковку, при запуске программа не может отработать успешно.

  > [!missing] 
>  2. Понять, откуда в вашем случае g++ берет заголовочные файлы стандартной библиотеки, а также откуда он берет саму стандартную библиотеку. Научиться указывать g++ брать заголовочные файлы (в частности iostream) из другого места, а также искать код libstdc++ в другом месте. Попробовать таким образом скомпилить и запустить что-нибудь с либой C++, отличной от системной (без использования переменных окружения). (Кстати, таким образом можно например добиться, чтобы у вас код запускался с последней версией либы C++, хотя в системе такая версия не установлена)

# Lecture 2
  > [!done] 

file /usr/bin/ldd - это shell script ==TODO==
> [!missing] 
>  1) говорят, что ldd небезопасен. А именно, можно создать такую вредоносную программу a.out, что команда ldd a.out выполнит вредоносный код. Выясните, как такое возможно. Что на самом деле делает команда ldd? Как посмотреть зависимости бинарника от библиотек без риска выполнить вредоносный код?  
  2) разберитесь всё-таки (кто еще не разобрался), чем hidden символы отличаются от local. А что такое protected символы? Создайте хотя бы один такой символ.) выясните, что хранится в каждой из секций elf-файлов: strtab, shstrtab, interp, dynamic. А что такое (хотя бы в общих чертах) PLT и GOT? Попробуйте собрать свою so-шку с одной функцией. С помощью утилит strip / objcopy сделайте так, чтобы все ненужные секции из этой so были убраны, и файл занимал бы менее 1 КБ. Слинкуйтесь и проверьте, что всё работает
  >  3) что за файлы имеют расширение .a? Как создавать, просматривать содержимое и использовать эти файлы при линковке? Используйте утилиту ar, чтобы создать такой файл из нескольких .o-файлов. Затем слинкуйте с полученным .a-файлом какую-нибудь прогу и проверьте, что всё работает.  
>4. Выясните, где на вашей системе сохраняются coredump-файлы, и научитесь читать их с помощью gdb (или другого дебаггера, это не принципиально). В качестве практики создайте любую программу, которая вызывает segfault или деление на ноль, получите coredump и прочитайте его через дебаггер.
>	Подводный камень: возможно, в вашей системе по умолчанию coredump файлы не создаются. В таком случае выясните, как добиться, чтобы они создавались. Одна из возможных причин, почему они не создаются - это неверно настроенные лимиты ulimit -c. Если у вас это так, выясните, что это значит, и настройте правильно. Рекомендую это упражнение проделать всем без исключения, ибо читать кордампы - это один из базовых навыков, что ожидаются от разработчиков c++ на практике.
