# 1. Overview

Системный вызов (syscall) — это запрос от программы к ядру ОС на выполнение привилегированной операции (ввод-вывод, управление памятью, процессами и т.д.).
- Т.е. функция, которая является точкой входа с взаимодействием с ОС.

Это единственный легальный способ взаимодействия пользовательского процесса с аппаратурой и ресурсами ОС. Реализуется через специальный механизм прерываний (например, `int 0x80` на x86, `syscall`/`sysenter` на современных архитектурах).

- В большинстве случаев работа с syscall'ами осуществляется через функции-обёртки (wrappers) из стандартной библиотеки C, которые:
    - Удобно передают аргументы
    - Обрабатывают возвращаемые значения
    - Устанавливают `errno` при ошибках
    - Избавляют от необходимости писать ассемблерный код

**Просмотр списка системных вызовов:**
```bash
man syscalls
```

## 1.1. Трассировка системных вызовов: `strace`

**Посмотреть, какие syscall'ы делает программа:**
```bash
# Трассировка выполнения программы
strace a.out

# Мониторинг уже запущенных процессов
strace -p {PID}
```

**Ключевые флаги `strace`:**
- `-c` — статистика по вызовам и времени
- `-e trace=file` — только сисколлы, связанные с файлами
- `-e trace=network` — только сетевые сисколлы
- `-f` — трассировать также дочерние процессы
- `-o file` — вывод в файл

Примеры:
```bash
# Трассировка конкретного процесса
strace -p 1234 -e write,read

# Просмотр сисколлов, связанных с открытием файлов
strace -e open,openat,open_by_handle_at ./a.out
```

## 1.2. Обработка ошибок системных вызовов
- Немного забежим наперед, рассматривая примеры с syscall'ом `write`, который пишет в файловый дескриптор
### 1.2.1. Глобальная переменная `errno`

При неудачном выполнении сисколла обёрточная функция возвращает `-1` (или `NULL`), а код ошибки записывается в `errno`.
- Возможные ошибки различных syscall'ов описаны в `man`'е

> **Важно:** `errno` — это **thread-local переменная** в современных системах (каждый поток имеет свою копию).

```c
#include <errno.h>
#include <stdio.h>
#include <string.h> // для strerror

#include <unistd.h>

int main() {
    write(3, "Hello world!", 10);
    // errno содержит код ошибки (например, 9 для EBADF)
    printf("Error code: %d\n", errno);  // Да, это глобальная переменная (почти)
    printf("Error message: %s\n", strerror(errno));
}
```

**Правильная обработка ошибок:**
```c
#include <errno.h>

if (errno == EBADF) {  // глобальные константы ошибок
    printf("Bad file descriptor\n");
    return 1;
}
```

> **Глубина:** `errno` определён как макрос, разворачивающийся в вызов функции `__errno_location()`, возвращающей указатель на thread-local переменную.

**Важно:** Всегда проверяйте возвращаемые значения сисколов. Даже «безопасные» вызовы вроде `write()` могут вернуть `-1` (например, при записи в разорванный pipe).

# 2. Системные вызовы ввода-вывода (I/O)

Справка по работе с файлами в Linux:
- **Вывод с перезаписью файла:** `command > file.txt`
- **Вывод с добавлением в файл:** `command >> file.txt`
- **Перенаправление потоков:**
    - `./program 1> stdout.txt 2> stderr.txt` (отдельно)
    - `./program > output.txt 2>&1` (объединить stderr в stdout)
    - `./program 2> /dev/null` (подавить stderr)

## 2.1. Базовые syscall'ы

### 2.1.1. `write` — запись в файловый дескриптор
- Получим мануал по syscall'у write (он из главы 2 (см. `man man`))
```bash
man 2 write
```

```c
#include <unistd.h>

ssize_t write(int fd, const void buf[.count], size_t count);
```
- `fd` — файловый дескриптор
    - `stdin`, `stdout`, `stderr` имеют номера 0, 1, 2 соответственно
    - Поэтому перенаправление работает как `1>test.txt`
- Возвращает количество **фактически записанных байтов** (да, может быть меньше `count`!)
- При ошибке возвращает `-1`

**Пример 1:**
- Правильно писать через цикл: `write` может записать не с первой попытки
```cpp
#include <unistd.h>

int main() {
    const char* str = "Hello world!";
    int len = 12;  // Исправлено: полная длина строки
    int count = len;
    while (count > 0) {
        int res = write(1, str + len - count, count);
        if (res < 0) {
            return 1;  // Обработка ошибки
        }
        count -= res;
    }
}
```

**Пример с ошибкой:**
```cpp
#include <unistd.h>

int main() {
	return write(3, "Hello world!", 12);  // fd=3 не существует
}
```

```bash
./a.out
echo $?
# 255 (она же -1)
```

### 2.1.2. Буферизация ввода-вывода

```cpp
#include <iostream>

int main() {
	for (int i = 0; i < 100'000; ++i) {
		std::cout << i << ' ';
	}
}
```

```bash
strace a.out
```

- Увидим, что `write` вызывается для пачки чисел и все строки длиной 1024 (1Кб)
- На самом деле, все `stream`'ы буфферизируются (`printf` тоже)

```cpp
std::cout.flush();  // Принудительное проталкивание буффера
```

### 2.1.3. `read` — чтение из файлового дескриптора

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```
- Читает `count` байт из файлового дескриптора
- Возвращает количество **прочитанных байтов** (0 — конец файла, -1 — ошибка)
- **Важно:** `read()` может вернуть меньше байтов, чем запрошено, даже если данные ещё есть

**Пример:**
```cpp
#include <unistd.h>

int main() {
    char buffer[1024];
    ssize_t bytes_read;
    while ((bytes_read = read(0, buffer, sizeof(buffer))) > 0) {
        write(1, buffer, bytes_read);
    }
    if (bytes_read == -1) {
        // Обработка ошибки
        return 1;
    }
    return 0;
}
```

### 2.1.4. `open` — открытие файла

```bash
man open    # C-шная функция (fopen, freopen)
man 2 open  # Сисколы (open)
```

```c
#include <fcntl.h>
int open(const char *pathname, int flags, mode_t mode);
```

- `flags`: комбинация флагов доступа и модификаторов
    - `O_RDONLY`, `O_WRONLY`, `O_RDWR` — режим доступа
    - `O_CREAT` — создать файл, если не существует
    - `O_TRUNC` — обрезать файл до нулевой длины
    - `O_APPEND` — дописывать в конец
    - `O_EXCL` — с `O_CREAT`: завершиться ошибкой, если файл существует
    - `O_NONBLOCK` — неблокирующий режим
    - `O_SYNC` — синхронная запись (ждать физической записи на диск)
- `mode`: права доступа при создании файла (например, `0644`)

```cpp
#include <fcntl.h>
#include <unistd.h>

int main() {
	int fd = open("output.txt", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);
	
	const char* str = "Hello world!";
	int len = 10;
	int count = len;
	while (count > 0) {
		int res = write(fd, str + len - count, count);
		if (res < 0) {
			return 1;
		}
		count -= res;
	}
	
	close(fd);
	return 0;
}
```
Важно закрыть файл. Конечно, в конце ОС автоматически все закроет (как и очисит всю динамическую память). НО:
- Количество открытых файловых дескрипторов на процесс ограничено (`ulimit`).
- Если программа работает долго и открывает много файлов без закрытия, может исчерпаться лимит.
- Явное закрытие освобождает ресурсы немедленно, что особенно важно в циклах или при работе с большим количеством файлов.

Если файл уже был создан, то содержимое будет перетираться (полностью не сотреться, как с `std::ifstream`, а будет заменятся по мере продвижения каретки записи)

Запустим программу выше через `strace` - увидим, что вернул `fd=3` и что вызвался syscall `openat`

А если открыть файл 2 раза? Каждое открытие файла через `open()` создаёт новое открытое файловое описание. У каждого будут свои позиции чтения/записи, флаги состояния. Но оба будут ссылаться на один и тот же inode (файл на диске).

### 2.1.5. `openat` — открытие относительно директории

```c
int openat(int dirfd, const char *pathname, int flags, ...);
```

- Позволяет указать относительный адрес относительно директории `dirfd`
	- То есть вначале передается файловый дескриптор директории, относительно которой считается `pathname`
- `dirfd` может быть `AT_FDCWD` (текущая рабочая директория)
- Позволяет избежать race conditions при работе с относительными путями

#### 2.1.5.1. Race condition
**Race condition** (состояние гонки) — это ситуация, когда результат выполнения программы зависит от порядка выполнения потоков/процессов.  
Например, если один процесс проверяет существование файла, а другой в этот момент его удаляет/переименовывает, может возникнуть ошибка.  
`openat()` помогает избежать этого, используя файловый дескриптор директории как точку отсчёта, что делает операцию атомарной относительно этой директории.

**Конкретный пример уязвимости:**  
Программа с повышенными привилегиями (например, setuid-программа) должна открыть файл `./etc/config` в своей поддиректории.

```cpp
// Уязвимый код
int fd = open("./etc/config", O_RDONLY);
```

Здесь `open` осуществляется по относительному пути. Последовательность действий такова:
1. Ядро ОС (или библиотека C) преобразует относительный путь `"./etc/config"` в абсолютный.
2. Для этого оно смотрит в текущую рабочую директорию (CWD) процесса.
3. CWD — это глобальное свойство процесса. Его можно изменить системным вызовом `chdir()`.
4. Если между шагом "определили CWD" и шагом "открыли файл" другой поток этого же процесса или совсем другой процесс изменит CWD (через `chdir`) или переименует/удалит один из каталогов в цепочке пути, то `open()` попытается открыть файл уже в неверном месте. Это и есть **состояние гонки (TOCTOU - Time-Of-Check-Time-Of-Use)**.

В этом примере злоумышленник, как пример, может создать символическую ссылку `etc`, которая в момент проверки указывает на легальную поддиректорию, но между вызовами `open()` он может быстро поменять её, чтобы она указывала, например, на `/etc/passwd`. Программа откроет не тот файл, на который рассчитывала.

`openat()` же **фиксирует (anchor)** точку в файловой системе не через "путь" (который может измениться), а через файловый дескриптор (`dirfd`).

### 2.1.6. `lseek` — перемещение указателя в файле
- Сдвинуть каретку

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

- `whence`: `SEEK_SET` (начало), `SEEK_CUR` (текущая позиция), `SEEK_END` (конец)
- Возвращает новую позицию (относительно начала) или `(off_t)-1` при ошибке

```cpp
#include <fcntl.h>
#include <unistd.h>

int main() {
	int fd = open("output.txt", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);
	
	const char* str = "Hello world!";
    write(fd, str, 10);
	
	int off = lseek(fd, 5, SEEK_SET);  // Перемещаемся на 5-й байт от начала
	write(fd, str, 10);                // Записываем "Hello"

	close(fd);
	return 0;
}
```
- Выведет `HelloHello world!`

Стоит упомянуть интересное свойство. В линуксе файлом может быть последовательность непрерывных отрезков, разделенные нулями.

**Про разреженные файлы (sparse files):**
- Если вызвать `lseek` и сдвинуть каретку за пределы дескриптора (файла), то при следующей записи создастся "дырка" (hole) из нулей (`\0`)
- Если вызвать `cat`, то "дыры" он просто не выведет, и прочитает файл как будто бы непрерывно, но минуя нули.
- На диске "дырки" не занимают места (блоки не выделяются)
- `ls -l` показывает **логический размер** (т.е. покажет расстояние от первого до последнего символа - это неправильный размер), `du` показывает **физический размер**

```bash
# Создание разреженного файла
dd if=/dev/zero of=sparse bs=1 count=0 seek=1G
ls -lh sparse  # покажет 1G
du -h sparse   # покажет 0, т.к. блоки не выделены
```

## 2.2. Программа `tee` — практический пример

**Задача:** Реализовать аналог команды `tee`, которая читает из stdin и пишет одновременно в stdout и в файл.

```cpp
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
    int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open");
        return 1;
    }
	
    char buffer[4096];
    ssize_t bytes;
    while ((bytes = read(0, buffer, sizeof(buffer))) > 0) {
        // Пишем в stdout (fd=1)
        if (write(1, buffer, bytes) != bytes) {
            perror("write to stdout");
            return 1;
        }
        // Пишем в файл
        if (write(fd, buffer, bytes) != bytes) {
            perror("write to file");
            return 1;
        }
    }
	
    if (bytes == -1) {
        perror("read");
        return 1;
    }
	
    close(fd);
    return 0;
}
```

## 2.3. Управление правами и владельцами

```bash
chown user:group file  # изменить владельца и группу
chgrp group file       # изменить только группу
```

### 2.3.1. `chmod` — изменение прав доступа
- Есть команда `chmod`, а есть syscall `chmod`
```c
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
```

### 2.3.2. `chown` — изменение владельца файла
```c
#include <unistd.h>
int chown(const char *pathname, uid_t owner, gid_t group);
```

## 2.4. Работа с директориями

### 2.4.1. `opendir` / `readdir` / `closedir`
- Это функции стандартной библиотеки C (не syscall'ы)
- Внутри используют syscall `getdents64` (очень неудобный к использованию напрямую)

- `opendir` возвращает `DIR*`
- `readdir` принимает `DIR*`, возвращает `dirent*` (directory entry)
- `closedir` принимает `dirent*`

```c
#include <dirent.h>
#include <stdio.h>

int main() {
    DIR* dir = opendir(".");
    if (!dir) {
        perror("opendir");
        return 1;
    }
    
    struct dirent* entry;
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
    }
    
    closedir(dir);
    return 0;
}
```

> **Глубина:** `struct dirent` может иметь переменную длину из-за имён файлов. Поле `d_reclen` указывает реальный размер записи.

**`readdir` работает итеративно:**
```cpp
DIR* dir = opendir(path);

struct dirent* entry;

while ((entry = readdir(dir)) != NULL) {
	printf("%s\n", entry->d_name)
}

closedir(dir);
```

### 2.4.2. О правах на директорию
- В Linux всё — это файлы, включая директории
- В `ls -l` директории помечаются сначала флагом `d`.

Существуют права на чтение, запись и исполнение.
- Даже если у пользователя нет прав на чтение файла, он все равно может узнать про этот файл (например, `ls -l` покажет инфу о файле). Но содержимое читать не получится

**Про права на директорию:**
- **Чтение (`r`)** — позволяет получить список имён файлов в директории (`ls`) (т.е. посмотреть содержимое)
- **Запись (`w`)** — позволяет создавать/удалять/переименовывать файлы в директории
- **Исполнение (`x`)** — позволяет «войти» в директорию (`cd`) и получить доступ к метаданным файлов (своего рода первичный доступ)

> **Пример:** Если есть только право на исполнение (`--x`), нельзя увидеть список файлов, но если имя известно, можно открыть файл (при наличии прав на него).
> Если же исполнять нельзя, то файлы доступны не будут (разве что читать, если дано право на чтение, и то узнать ТОЛЬКО название и тип файла (ни права, ни автора доступно не будет))

```bash
mkdir testdir
cd testdir
touch hahaha
echo "Hahaha!" > hahaha
```

- Уберу у директории `testdir` право на чтение
```bash
chmod u-r testdir
```

### 2.4.3. Создание и удаление директорий

- Есть свои syscall'ы
```cpp
#include <sys/stat.h>   // mkdir
#include <unistd.h>     // rmdir

mkdir("newdir", 0755);  // Создание директории
rmdir("newdir");        // Удаление пустой директории
```

### 2.4.4. Биты

#### 2.4.4.1. Sticky bit (`t` в правах директории):  
Разрешает удаление файлов только владельцам. Пример:

```bash
chmod +t /tmp
ls -ld /tmp  # drwxrwxr-t
```

#### 2.4.4.2. SUID-бит (`s` или `S`):
Это специальный флаг, который можно установить на исполняемый файл. Если он установлен, то программа при запуске временно получает права владельца этого файла, а не пользователя, который ее запустил.

**Пример:**
```bash
chmod u+s /usr/bin/passwd
ls -l /usr/bin/passwd  # -rwsr-xr-x
```
Если `x` отсутствует, отображается `S`. То есть как бы SUID-бит есть, но владелец исполнять файл не может.

#### 2.4.4.3. SGID-бит (`s` для группы):  
Аналогично SUID, но для группы. **Пример:**
```bash
chmod g+s /usr/bin/write
```

Но у SGID есть важная особенность. Если SGID установлен на директорию, то все файлы и поддиректории, созданные внутри нее, будут наследовать группу-владельца этой директории, а не первичную группу пользователя, который их создал.

**Пример:**
1. Есть группа `developers` и каталог `/project`.
2. Вы устанавливаете на `/project` SGID и назначаете группу `developers`:
```bash
chown :developers /project
chmod g+s /project
ls -ld /project
# drwxrwsr-x 2 root developers 4096 мар 20 10:00 /project
```
3. Теперь любой файл, созданный в `/project` любым пользователем, будет автоматически принадлежать группе `developers`. Это обеспечивает корректный общий доступ для всей команды без ручной смены групп у каждого нового файла.

## 2.5. Метаданные файлов: `stat`, `fstat`, `lstat`

Хотим, прямо как `ls -l`, узнать тип файла, права, владельца, время изменения и т.д.

```bash
strace ls -l
```

- Видим, что `ls` вызывает `statx` (или `lstat`/`fstat`)

**Пример:**
```cpp
#include <sys/stat.h>
#include <dirent.h>
#include <stdio.h>

int main() {
    DIR* dir = opendir(".");
    struct dirent* entry;
    struct stat statbuf;  // НЕ указатель - память на стеке
    
    while ((entry = readdir(dir)) != NULL) {
        const char* name = entry->d_name;
        int res = stat(name, &statbuf);  // Передаём адрес
        if (res == 0) {
            printf("%s %ld bytes\n", name, statbuf.st_size);
        }
    }
    
    closedir(dir);
    return 0;
}
```
- Примерно так `ls` и работает. Надо лишь добавить вывод прав, владельца, времени.

**Различия между функциями:**
- `stat()` — информация по пути, разыменовывает symlinks
- `lstat()` — информация по пути, НЕ разыменовывает symlinks
- `fstat()` — информация по файловому дескриптору

**Поля `struct stat`:**
- `st_mode` — тип файла и права доступа
- `st_ino` — номер inode
- `st_nlink` — количество жёстких ссылок
- `st_uid`/`st_gid` — владелец и группа
- `st_size` — размер в байтах
- `st_blocks` — число выделенных блоков по 512 байт
- `st_atime`/`st_mtime`/`st_ctime` — временные метки

### 2.5.1. Современная альтернатива: `statx`
- `statx` появился в Linux 4.11, предоставляет больше полей (время создания) и эффективнее

```cpp
#define _GNU_SOURCE
#include <sys/stat.h>
#include <fcntl.h> // for AT_FDCWD
#include <stdio.h>  

int main() {
    struct statx stx;
    if (statx(AT_FDCWD, "file.txt", AT_SYMLINK_NOFOLLOW, STATX_ALL, &stx) == 0) {
        printf("Size: %lu\n", stx.stx_size);
        printf("Birth time: %lld.%u\n", stx.stx_btime.tv_sec, stx.stx_btime.tv_nsec);
    }
    return 0;
}
```

# 3. Ссылки на файлы

- У файла может иметь несколько равноправных имен
- На низком уровне все работает за счет ID'шников

## 3.1. Жёсткие ссылки (Hard Links)

**Link - привязать имя к файлу:**
```bash
echo "Hahaha!" > hahaha
ln hahaha pupupu  # Создание жёсткой ссылки
```

```bash
echo "Pupupu!" >> pupupu
cat hahaha
cat pupupu  # Its equal!
```

- Создаёт новую запись в директории, указывающую на тот же inode
- Увеличивает счётчик ссылок `st_nlink`
- Работает только в пределах одной файловой системы
- Все ссылки равноправны, а значит,  эти файлы неотличимы с точки зрения содержимого

```bash
ls -l
```
- У `hahaha` и `pupupu` будет одно выделяющее свойство: число ссылок = 2
	- Аналогия с `shared_ptr`

**Удаление (remove) файла:**
```bash
rm hahaha
```
- Удаляем не файл на диске, а ссылку
	- Если же у файла ссылок нет и нет открытых дескрипторов, то удаляется он сам
	- Буквально как с `shared_ptr`

**Переименование (rename) файла:**
```bash
mv pupupu lololo
```

> На самом деле, директория физически - просто список вида: имя + тип + ID'шник
> ID'шник, т.е. номер inode'ы, включен в структуру `stat`. Можно также через `ls -i`

```bash
mkdir testdir
mv ololo testdir
ls -laRi
```

**Inode и `.`, `..`**: На самом деле, каждая директория содержит минимум 2 жёсткие ссылки:
  - `.` — ссылка на саму директорию
  - `..` — ссылка на родительскую директорию

У директории `testdir` изначально `st_nlink = 2`. При создании поддиректории `st_nlink` увеличивается (добавляется `..` из поддиректории)

## 3.2. Символические ссылки (Symbolic Links)
```bash
ln -s data.txt input.txt  # Создание символической ссылки
```

- Создаёт отдельный файл типа `symlink` (на Windows'овский манер - ярлык), содержащий путь к целевому файлу
- Имеет собственный inode
- Может указывать на файлы в других ФС и даже на несуществующие пути
- Его размер - ровно длина названия файла.

```bash
ls -l  # Тип файла 'l', размер — длина пути целевого файла
```

> Лучше всего создавать ссылки с абсолютными путями: если переместить ссылку, она может сослаться на другой файл, если указан относительный путь.

### 3.2.1. Syscall'ы для работы со ссылками

```bash
strace ln test.txt test2.txt      # Сисколл link()
strace ln -s test2.txt test3.txt  # Сисколл symlink()
strace rm test.txt                # Сисколл unlink()
strace mv old new                 # Сисколл rename()
```

**Сисколл `unlink`:**
- Уменьшает счётчик ссылок
- Удаляет файл с диска только при `st_nlink == 0`
- Если файл открыт процессом, удаление откладывается до закрытия всех дескрипторов

**Продвинуто. На самом деле:**
- `mv` использует `rename()` (внутри ФС) или `copy + unlink` (между ФС)
- `rm` использует `unlink()` (файлы) или `rmdir()` (ТОЛЬКО пустые директории)

**Упрощённая версия `ln`:**
```cpp
// ln source link (без -s)
link(argv[1], argv[2]);
// ln -s source link
symlink(argv[1], argv[2]);
```

**Про разные ФС:**
Linux поддерживает множество файловых систем одновременно (ext4, btrfs, XFS, tmpfs и др.). Каждая ФС монтируется в определённую точку дерева каталогов.  
Жёсткие ссылки (`link()`) работают только в пределах одной ФС, а символические (`symlink()`) могут указывать на любой путь, в том числе на другую ФС.

# 4. Дублирование файловых дескрипторов
- Duplicate a file descriptor

## 4.1. Открытое файловое описание

- **Открытое файловое описание (open file description)** — структура ядра, содержащая состояние файла (смещение, флаги доступа). **Файловый дескриптор** — лишь ссылка на неё
- `dup` создаёт новый дескриптор, ссылающийся на то же **открытое файловое описание**:

```c
int fd1 = open("file.txt", O_RDONLY);
int fd2 = dup(fd1);  // fd1 и fd2 разделяют смещение (offset)
read(fd1, buf, 10);  // offset увеличится для обоих дескрипторов
```

## 4.2. `dup`, `dup2`, `dup3`
```cpp
#include <unistd.h>
int dup(int oldfd);                 // возвращает новый fd (минимальный свободный)
int dup2(int oldfd, int newfd);     // явно указывает newfd (закрывает его, если открыт)
int dup3(int oldfd, int newfd, int flags); // с флагами (например, O_CLOEXEC (автоматически закрывает дескриптор при вызове exec))
```

- Используется для перенаправления ввода-вывода (как `2>&1` в bash)
- Новый дескриптор разделяет одно и то же **открытое файловое описание**

**Пример:**
```cpp
// Перенаправляем stderr в stdout
dup2(1, 2);

// Перенаправляем stdout в файл
int fd = open("log.txt", O_WRONLY | O_CREAT, 0644);
dup2(fd, 1);  // теперь stdout пишет в файл
close(fd);
```

# 5. Расширенные атрибуты файлов

## 5.1. `chattr` и `lsattr`
- У файлов есть дополнительные аттрибуты, если файловая система не суперстарая (появилось при EXT-2, сейчас - EXT-4)
- Флаги хранятся в inode

**Поменять аттрибуты через `chattr`:**
```bash
sudo chattr +i output.txt  # Установка флага immutable
lsattr output.txt          # Просмотр атрибутов
ls -l                      # Здесь не видно
```

**Основные атрибуты:**
- `i` (immutable) — файл нельзя изменить, удалить, переименовать (если ты не суперюзер и без привилегий)
- `a` (append only) — можно только дописывать (полезно для логов)
- `A` (no atime) — не обновлять время последнего доступа
- `s` (secure deletion) — при удалении занулить блоки
- `u` (undeletable) — сохранить содержимое при удалении
- `E` - encrypt
- `F` - сделать все пути нечуствительными к регистру

**Замечание:** Некоторые аттрибуты можно менять только с повышенными привилегиями.

## 5.2. `fcntl` — управление открытыми файловыми дескрипторами
```cpp
#include <fcntl.h>

// Установка неблокирующего режима
int flags = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);

// Установка close-on-exec
fcntl(fd, F_SETFD, FD_CLOEXEC);
```

## 5.3. `ioctl` — универсальный интерфейс управления
- Управление устройствами (терминалы, диски, сетевые интерфейсы)
- Управление специальными файлами
- Очень разнообразный, зависит от устройства

**Иначе говоря:**
- `fcntl` — управление **файловыми дескрипторами** (флаги доступа, блокировки, close-on-exec)
- `ioctl` — управление **устройствами и специальными файлами** (изменение размера терминала, управление диском). Более мощный, но нестандартизированный

**Пример `ioctl` для терминала:**
```cpp
#include <sys/ioctl.h>
// OR #include <linux/fs.h>

struct winsize ws;
ioctl(STDIN_FILENO, TIOCGWINSZ, &ws);  // Получить размер терминала
```

**Пример `ioctl` для файловых атрибутов:**
```cpp
#include <sys/ioctl.h>
// OR #include <linux/fs.h>

int flags = FS_IMMUTABLE_FL;
ioctl(fd, FS_IOC_SETFLAGS, &flags);  // Установить immutable-флаг (аналог chattr +i). Требует прав суперпользователя и поддержки ФС.
```
