- В процессоре, как уже знаем, есть регистры, кеши, специальный регистр, располагающий адресом таблицы страниц, и прочее.

# 1. Режимы работы процессора
x86-64 поддерживает несколько режимов (ring levels):
- Ring 0: ядро ОС (полный доступ);
- Ring 1-2: исторически использовались для драйверов;
- Ring 3: пользовательские приложения (ограниченный доступ).
Переход между кольцами происходит через прерывания, исключения или сисколлы.

# 2. Interrupt Descriptor Table
В процессоре есть механизм прерываний.
[Interrupt Descriptor Table](https://en.wikipedia.org/wiki/Interrupt_descriptor_table) (IDT) содержит адреса функций, которые нужно вызвать при прерываниях (исключительных ситуациях).

**Если по правде:** В архитектуре x86 события, требующие обработки через IDT, делятся на три основные группы: аппаратные прерывания, исключения процессора и программные прерывания. Однако внутри этих групп есть дополнительные подтипы, которые упомянаться далее не будут.

**Три основные группы:**
1. Аппаратное прерывание (IRQ)
	- Нажали пробел на клавиатуре;
	- Сетевая карта подала сигнал;
	- Прерывание таймера.
2. Программное прерывание (Software interrupt)
	- Вызов `int 0x80` для syscall.
3. Исключение (Exception)
	- Деление на 0;
	- Page Fault.

| Тип события (x86)          | Синхронность             | Источник                              | Примеры                                                        | Обработка в ОС (Linux)                                                                        |
| -------------------------- | ------------------------ | ------------------------------------- | -------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| **Аппаратное прерывание**  | Асинхронное              | Внешние устройства                    | Таймер (IRQ0), клавиатура (IRQ1), сетевая карта                | Вызов обработчика драйвера устройства                                                         |
| **Исключение процессора**  | Синхронное               | Процессор (при выполнении инструкции) | Деление на 0 (#DE), Page Fault (#PF), General Protection (#GP) | Отправка сигнала процессу (SIGFPE, SIGSEGV) или обработка ядром (например, подкачка страницы) |
| **Программное прерывание** | Синхронное (явный вызов) | Инструкция `INT n`                    | `int 0x80` (сисколл в 32-bit), `int 0x3` (отладка)             | Переход в ядро для обработки системного вызова или отладки                                    |

**Замечание**: В архитектуре x86 деление на ноль вызывает исключение процессора `#DE` (Divide Error). Это не то же самое, что исключения в C++. В C++ деление целых чисел на ноль — это неопределённое поведение, и компилятор не генерирует код для проверки. Но если инструкция деления выполняется с нулевым делителем, процессор генерирует `#DE`, и ОС обычно завершает процесс с сигналом `SIGFPE`.

Так, в случае `#DE` Linux отправит `SIGFPE` процессу, а в случае `#PF` — попытается подгрузить страницу (попытается — значит проверит ее на легитимность: что это не `NULL`, она не чужая и есть нужные права) и в случае неудачи отправит `SIGSEGV`.

**Примечание**: Название сигнала `SIGFPE` (Floating-Point Exception) исторически сложилось, но сигнал приходит и при целочисленном делении на 0.

| Тип события на уровне x86  | Пример               | Что происходит в Linux              |
| -------------------------- | -------------------- | ----------------------------------- |
| **Аппаратное прерывание**  | IRQ0 (таймер)        | Обработка в драйвере                |
| **Исключение процессора**  | `#DE` (деление на 0) | Отправка SIGFPE процессу            |
| **Исключение процессора**  | `#PF` (Page Fault)   | Подгрузка страницы или SIGSEGV      |
| **Программное прерывание** | `int 0x80` (сисколл) | Вызов обработчика системного вызова |

## 2.1. Переключение контекста
Вопрос состоит в следующем: как при исполнении ассемблерного кода процессор понимает, когда ему надо переключиться на другой процесс?

У процессора есть таймер, который способен генерировать прерывания. И есть отдельный тип — прерывание от таймера.
У процессора также есть таблица адресов, куда идти, если случилось прерывание.

ОС стоит во главе всех процессов. Она и заводит таблицу прерываний и обеспечивает своевременное прерывание от таймера. Как только процессор переходит по адресу указанной функции, ОС, фактически снова полноправная, ставит следующий процесс исполняться на определенное ей количество тактов.
На момент прерывания ОС знает все: в регистрах процессора записан номер процесса и пр.

### 2.1.1. Привилегированные инструкции
Можно ли поменять эту таблицу?
У процессора есть инструкции, которые можно выполнять исключительно в привилегированном режиме. Примером послужит LIDT (Load IDT) - инструкция, которая загружает таблицу векторов прерываний (interrupt vector table (IVT)).
```cpp
#include <stdint.h>

struct idt_record
{
    uint16_t  limit;      /* Size of IDT array - 1 */
    uintptr_t base;       /* Pointer to IDT array  */
} __attribute__((packed));

void load_idt (struct idt_record *idt_r)
{
    __asm__ ("lidt %0" :: "m"(*idt_r));
}
```
Команду `lidt` можно вызвать только в привилегированном режиме. Привилегированной же является лишь ОС. И у процессора есть отдельные флаги, обозначающие уровень привилегированности да текущий момент. ОС же, перед тем, как отдать управление какому-либо процессу, ставит процессор в защищенный режим. При прерывании же при привилегированный режим возвращается.
- На деле, в процессоре есть целые кольца защиты, то есть режимов много.

## 2.2. Вызов прерываний (инструкция INT)
**В ассемблере есть инструкция `int` (interrupt):**
```cpp
#include <stdio.h>

int main() {
	asm volatile ("int $0x0\n");  // Div by 0
	
	return 0;
}
```
Правда при запуске будет Segmentation Fault.
- В пользовательском режиме нет обработчика деления на 0;
- ОС не разрешает процессам обрабатывать исключения ядра.

**Полезно это вызывать с кодом 3 — Breakpoint — `INT 3`:**
```cpp
#include <stdio.h>

int main() {
	asm volatile ("int $0x3\n");  // Breakpoint
	
	return 0;
}
```
При запуске выведется: `Trace/breakpoint trap (core dumped)`.

## 2.3. Смысл IDT. Пример внутренней обработки

**Почему IDT является хорошим решением обработки этих 3-х видов прерываний:**
1. Единая точка конфигурации: ОС загружает одну таблицу при старте, и процессор знает: "все прерывания обрабатываются через этот механизм".
2. Изоляция ядра от приложений:
3. Гибкость: ОС может динамически менять обработчики:
```c
// Псевдокод инициализации IDT в ядре Linux
set_idt_gate(0, divide_error_handler);
set_idt_gate(1, debug_handler);
set_idt_gate(0x80, system_call_handler);
lidt(&idt_descriptor);  // Загрузить IDT в процессор
```

### 2.3.1. Сценарий обработки прерывания
Допусим, программа пытается записать в read-only память

```c
// Программа пользователя
char *ptr = (char*)0x1000;  // Указатель на read-only память
*ptr = 'A';  // Запись => вызывает исключение!
```

**Что происходит внутри:**
1. Генерация исключения:
```text
CPU: "Ой, запись в защищённую память!"
- Генерирует исключение #13 (General Protection Fault)
- Смотрит в IDT[13] за адресом обработчика
```

2. Переход в ядро:
```asm
; Автоматически процессором:
push eflags, cs, eip, error_code  ; Сохраняет контекст
jmp [IDT[13].offset]              ; Переход к обработчику
```
    
3. Обработчик в ядре Linux:
```cpp
// В arch/x86/kernel/traps.c
dotraplinkage void do_general_protection(struct pt_regs *regs)
{
    // Анализ: была ли ошибка в пользовательском процессе?
    if (user_mode(regs)) {
        // Да, это программа накосячила
        force_sig(SIGSEGV);  // Отправляем сигнал
        return;
    }
    // Нет, это баг в ядре → паника
    panic("General protection fault in kernel");
}
```

4. Возврат к программе (через сигнал):
```text
Ядро => Программа: "Ты получила SIGSEGV"
Программа: (если не перехватила) => падает с "Segmentation fault"
```

# 3. Вызов syscall'ов
Syscall — это не просто вызов функции. Это целая процедура в виде перевода процессора в привилегированный режим, снятие всего с регистров и пр.

**Краткий путь сисколла в Linux x86-64:**
  1. Смена режима (Ring 3 → Ring 0);
  2. Сохранение контекста;
  3. Выполнение привилегированного кода;
  4. Возврат с восстановлением контекста.

## 3.1. Инструкция `SYSCALL`
На современных процессорах для syscall'ов есть отдельное одноименное прерывание.
- Ясно, что раннее вызывали лишь C'шные функции как прослойки.
Увидеть ассемблерную инструкцию можно, если какой-нибудь cpp-файл, фактически использующий syscall, скомпилировать с флагом `-static` и через `objdump` перевести в код ассемблера.
```asm
mov $0x14,%r9d
; ...
syscall
; ...
```
`0x14` - код syscall'а getpid.

**Пример прямого вызова `execve` через ассемблерную вставку:**
```cpp
#include <unistd.h>

int main() {
	const char* path = "/bin/ls";
	const char* argv[] = { "ls", "-l", NULL };
	const char* envp[] = { NULL };
	
	asm volatile (
		"mov $59, %%rax\n\t"      // номер syscall execve
		"mov %0, %%rdi\n\t"       // path
		"mov %1, %%rsi\n\t"       // argv
		"mov %2, %%rdx\n\t"       // envp
		"syscall"
		:
		: "r"(path), "r"(argv), "r"(envp)
		: "rax", "rdi", "rsi", "rdx", "rcx", "r11"
	);
	
	return 0;
}
```

### 3.1.1. Сравнение прерываний и сисколлов

Исторически и концептуально, системные вызовы **являются частным случаем прерываний**. Однако в современном Linux на x86-64 (где как раз-таки системный вызов выполняется инструкцией `SYSCALL`, а не `INT 0x80`), технически, это уже не прерывание в классическом смысле, а отдельный механизм:
- Они не используют громоздкую таблицу прерываний (IDT);
- У них меньше накладных расходов на сохранение контекста;
- Они сразу передают управление на заранее заданный адрес в ядре.
В современных процессорах, вместо IDT, для вызовов syscall'ов используются MSRs (Model-Specific Registers) для быстрых переходов.

# 4. Управление процессами через прерывания таймера
ОС использует прерывание таймера (IRQ0) для планирования задач.
На каждом тике таймера:
1. Таймер → прерывание.
2. Сохраняется контекст текущего процесса (регистры, состояние).
3. Планировщик выбирает следующий процесс.
4. Восстанавливается его контекст.
5. Возврат из прерывания (`iret`) передаёт управление новому процессу.
