- В процессоре, как уже знаем, есть регистры, кеши, специальный регистр, располагающий адресом таблицы страниц, и прочее

# Режимы работы процессора
x86-64 поддерживает несколько режимов (ring levels):
- Ring 0: ядро ОС (полный доступ).
- Ring 1-2: исторически использовались для драйверов.
- Ring 3: пользовательские приложения (ограниченный доступ).
Переход между кольцами происходит через прерывания, исключения или сисколлы.

# Interrupt Descriptor Table
В процессоре есть механизм прерываний.
[Interrupt Descriptor Table](https://en.wikipedia.org/wiki/Interrupt_descriptor_table) (IDT) содержит адреса функций, которые нужно вызвать при прерываниях (исключительных ситуациях)

Есть 3 типа прерываний:
1. Аппаратное прерывание (IRQ)
	- Нажали пробел на клавиатуре
	- Сетевая карта подала сигнал
	- Прерывание таймера
2. Программное прерывание (Software interrupt)
	- Вызов `int 0x80` для syscall
3. Исключение (Exception)
	- Деление на 0
	- Page Fault

| Тип события (x86)          | Синхронность             | Источник                              | Примеры                                                        | Обработка в ОС (Linux)                                                                        |
| -------------------------- | ------------------------ | ------------------------------------- | -------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| **Аппаратное прерывание**  | Асинхронное              | Внешние устройства                    | Таймер (IRQ0), клавиатура (IRQ1), сетевая карта                | Вызов обработчика драйвера устройства                                                         |
| **Исключение процессора**  | Синхронное               | Процессор (при выполнении инструкции) | Деление на 0 (#DE), Page Fault (#PF), General Protection (#GP) | Отправка сигнала процессу (SIGFPE, SIGSEGV) или обработка ядром (например, подкачка страницы) |
| **Программное прерывание** | Синхронное (явный вызов) | Инструкция `INT n`                    | `int 0x80` (сисколл в 32-bit), `int 0x3` (отладка)             | Переход в ядро для обработки системного вызова или отладки                                    |

**Замечание**: В архитектуре x86 деление на ноль вызывает исключение процессора `#DE` (Divide Error). Это не то же самое, что исключения в C++. В C++ деление целых чисел на ноль — это неопределённое поведение, и компилятор не генерирует код для проверки. Но если инструкция деления выполняется с нулевым делителем, процессор генерирует `#DE`, и ОС обычно завершает процесс с сигналом `SIGFPE`.

Так, в случае `#DE` Linux отправит `SIGFPE` процессу, а в случае `#PF` — попытается подгрузить страницу (попытается — значит проверит ее на легитимность: что это не NULL, она не чужая и есть нужные права) и в случае неудачи отправит `SIGSEGV`.

**Примечание**: Название сигнала `SIGFPE` (Floating-Point Exception) исторически сложилось, но сигнал приходит и при целочисленном делении на 0.

| Тип события на уровне x86  | Пример               | Что происходит в Linux              |
| -------------------------- | -------------------- | ----------------------------------- |
| **Аппаратное прерывание**  | IRQ0 (таймер)        | Обработка в драйвере                |
| **Исключение процессора**  | `#DE` (деление на 0) | Отправка SIGFPE процессу            |
| **Исключение процессора**  | `#PF` (Page Fault)   | Подгрузка страницы или SIGSEGV      |
| **Программное прерывание** | `int 0x80` (сисколл) | Вызов обработчика системного вызова |

# Переключение контекста
Вопрос состоит в следующем: как при исполнении ассемблерного кода процессор понимает, когда ему надо переключиться на другой процесс?

У процессора есть таймер, который способен генерировать прерывания. И есть отдельный тип — прерывание от таймера.
У процессора также есть таблица адресов, куда идти, если случилось прерывание.

ОС стоит во главе всех процессов. Она и заводит таблицу прерываний и обеспечивает своевременное прерывание от таймера. Как только процессор переходит по адресу указанной функции, ОС, фактически снова полноправная, ставит следующий процесс исполняться на определенное ей количество тактов. 
На момент прерывания ОС знает все: в регистрах процессора записан номер процесса и пр.

## Привилегированные инструкции
Можно ли поменять эту таблицу?
У процессора есть инструкции, которые можно выполнять исключительно в привилегированном режиме. Примером послужит LIDT (Load IDT) - инструкция, которая загружает таблицу векторов прерываний (interrupt vector table (IVT)). 
```cpp
#include <stdint.h>

struct idt_record
{
    uint16_t  limit;      /* Size of IDT array - 1 */
    uintptr_t base;       /* Pointer to IDT array  */
} __attribute__((packed));

void load_idt (struct idt_record *idt_r)
{
    __asm__ ("lidt %0" :: "m"(*idt_r));
}
```
Команду `lidt` можно вызвать только в привилегированном режиме. Привилегированной же является лишь ОС. И у процессора есть отдельные флаги, обозначающие уровень привилегированности да текущий момент. ОС же, перед тем, как отдать управление какому-либо процессу, ставит процессор в защищенный режим. При прерывании же при привилегированный режим возвращается.
- На деле, в процессоре есть целые кольца защиты, то есть режимов много

# Вызов прерываний (инструкция INT)
**В ассемблере есть инструкция `int` (interrupt):**
```cpp
#include <stdio.h>

int main() {
	asm volatile ("int $0x0\n");  // Div by 0
	
	return 0;
}
```
Правда при запуске будет Segmentation Fault.
- В пользовательском режиме нет обработчика деления на 0.
- ОС не разрешает процессам обрабатывать исключения ядра.

**Полезно это вызывать с кодом 3 — Breakpoint — `INT 3`:**
```cpp
#include <stdio.h>

int main() {
	asm volatile ("int $0x3\n");  // Breakpoint
	
	return 0;
}
```
При запуске выведется: `Trace/breakpoint trap (core dumped)`

# Вызов syscall'ов
Syscall — это не просто вызов функции. Это целая процедура в виде перевода процессора в привилегированный режим, снятие всего с регистров и пр.

**Полный путь сисколла в Linux x86-64:**
1. Пользовательский код помещает номер сисколла в `rax`, аргументы — в `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9`.
2. Выполняется инструкция `syscall`.
3. Процессор переключается в ring 0 (Ring 3 → Ring 0), сохраняет пользовательский `rip` в `rcx`, `rflags` в `r11`.
4. Прыгает на entry point сисколлов, заданный MSR (Model Specific Register).
5. Ядро выполняет работу, результат кладёт в `rax`.
6. `sysret` возвращает в пользовательский режим.

**Кратко:**
  1. Смена режима (Ring 3 → Ring 0).
  2. Сохранение контекста.
  3. Выполнение привилегированного кода.
  4. Возврат с восстановлением контекста.

## Инструкция SYSCALL
На современных процессорах для syscall'ов есть отдельное одноименное прерывание
- Ясно, что раннее вызывали лишь C'шные функции как прослойки
Увидеть ассемблерную инструкцию можно, если какой-нибудь cpp-файл, фактически использующий syscall, скомпилировать с флагом `-static` и через `objdump` перевести в код ассемблера.
```asm
mov $0x14,%r9d
; ...
syscall
; ...
```
`0x14` - код syscall'а getpid

**Пример прямого вызова `execve` через ассемблерную вставку:**
```cpp
#include <unistd.h>

int main() {
	const char* path = "/bin/ls";
	const char* argv[] = { "ls", "-l", NULL };
	const char* envp[] = { NULL };
	
	asm volatile (
		"mov $59, %%rax\n\t"      // номер syscall execve
		"mov %0, %%rdi\n\t"       // path
		"mov %1, %%rsi\n\t"       // argv
		"mov %2, %%rdx\n\t"       // envp
		"syscall"
		:
		: "r"(path), "r"(argv), "r"(envp)
		: "rax", "rdi", "rsi", "rdx", "rcx", "r11"
	);
	
	return 0;
}
```
- Компиляция: `g++ -static -o execve_test execve_test.cpp` (статическая линковка для прямого вызова).

### Сравнение прерываний и сисколлов

| Аспект                 | Прерывание                                                       | Системный вызов                       |
| ---------------------- | ---------------------------------------------------------------- | ------------------------------------- |
| Источник               | Аппаратура или `int`                                             | Программа                             |
| Синхронность           | Асинхронны, могут возникнуть в любой момент (таймер, устройство) | Синхронны, вызываются явно программой |
| Обработчик             | В ядре                                                           | В ядре                                |
| Типичное использование | Обработка событий устройств                                      | Запросы к ОС                          |

# Управление процессами через прерывания таймера
ОС использует прерывание таймера (IRQ0) для планирования задач.
На каждом тике таймера:
1. Таймер → прерывание.
2. Сохраняется контекст текущего процесса (регистры, состояние).
3. Планировщик выбирает следующий процесс.
4. Восстанавливается его контекст.
5. Возврат из прерывания (`iret`) передаёт управление новому процессу.
