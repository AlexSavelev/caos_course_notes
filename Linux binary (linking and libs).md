# ELF
- Рассматривая различные исполняемые или "полуисполняемые" файлы (например, `libstdc++.so` или `hello.o`), мы можем увидеть что их структура схожая, то есть одного и того же формата.
- Этот формат называется `ELF` (Executable or linkable file (format)) ==TODO==
	- Это линуксовский формат
	- В самом начале каждого такого файла есть шапка с явным указанием (ELF)

- Есть программа, которая рассказывает о ELF-файле
```bash
readelf -a a.out
```
- [[Programs#readelf]]

- Внимательно смотрим на Type ==TODO== DYN (Shared Object File, Position-Independent Executable file (PIE)), REL (Relocatable file), CORE (core-dump-файл)

- `Position-Independent` - адреса функций кодируются (записываются) относительными
- Иначе `-fno-pie` - `EXEC (Position-Dependent)`

# About linking
- Вообще, есть статическая и динамическая линковки. Статическая линковка (static -> до запуска) осуществляется на этапе линковки (соответственно, все сущности библиотеки статической линковки появляются в исходном файле). При динамической линковке в исходный файл записываются лишь адреса (и указания к подключению той или иной библиотеке). ==TODO==
- Поэтому, на самом деле, определения функций, ответственных за ввод/вывод в консоль, в `a.out` по-прежднему будут отсутствовать: программа обращается к стандартной библиотеке прямо в Runtime, которая, к слову, используется одновременно несколькими программами.
	- То есть `a.out`, как и большинство программ на C++, не самодостаточны
- И благодаря этому используется куда меньше ресурсов оперативной памяти

# Shared Object
- Динамическая библиотека (`.so`)
	- В Windows - DLL (Dynamic Link Library)

- Print shared object dependencies
	- Очень полезная тулза
```bash
ldd a.out
```

==TODO== LD_PRELOAD

# LD
- Стандартный линуксовский линковщик

- Попробуем слинковать зависимости
```bash
ld hello.o /lib/x86_64-linux-gnu/libstdc++.so.6 /lib/x86_64-linux-gnu/libc.so.6
```
- `ld` выведет множество warning'ов о невозможности найти символы для `_start` и т.д.: то есть нужно еще что-то

- Нужно еще `/usr/lib/gcc/x86_64-linux-gnu/12/crtbeginS.o` и `crtendS.o` (C Run TIme)
==TODO== почему с суффиксом `S`?

- Запускаем и пишем `echo $?` (статус окончания последней программы). Получаем 1 (ошибка). То есть еще не достаточно

- Ему не хватает динамической линковки
	- Не путать с обычным линковщиком: динамический линковщик запускается перед фактическим запуском программы. Он создает нам окружение: все библиотеки, стек и т.п. ==TODO==
	- Когда мы запускаем `./a.out`, сначала запускается динамический линкировщик, который затем отдает управление `a.out`

- Сравним через `ldd` файлы - наш и нормально скомпилированный, через `g++`
- Нормальный: есть `/lib64/ld-linux-x86_64.so`
- Наш: есть `/lib/ld64.so`
	- ==TODO== overview


- Теперь слинкуем программу еще и с `-I /lib64/ld-linux-x86_64.so`. Будет также жаловаться на `_start`, зато программа заработает: но в самом конце будет Segmentation Fault.
	- Здесь будет вызываться не `_start`, а сразу `main()`
	- `return 0;` не знает, куда идти: в стеке адрес возврата отсутствует
		- Хотя может это потому, что `std::cin` - глобальная переменная, которую надо сынициализировать до `main`'а ==TODO== what is right?
	- Что же будет со статическими переменными и глобальными объектами, которые создаются в `_start`'е, до `main`'а

# Статическая сборка

- Это когда делаем свой файл, не зависящий от библиотек
- Скомпилируем `hello.cpp` через g++ и `ldd a.out`
	- Зависит от множества библиотек, весит 16Кб

- Скомпилируем так:
```bash
g++ -static hello.cpp
```
- Теперь не зависит ни от чего (т.е. самодостаточный), но весит очень много
	- Вроде даже не нужен динамический линковщик (мб он уже внутри)

- Но рассмотрим проблему: хочу запустить скомпилированный на убунте файл на астра линкуксе
	- Разные версие `libc`, и т.д.
- Хотим, чтобы можно было запустить везде
	- Где совпадают архитектура, интерфейс системных вызовов...


# Создаем библиотеку

- Рассмотрим код
	- В `hello.cpp` `multiply` как бы есть, но он не зарезолвен
```cpp
// mylib.cpp:

int multiply(int a, int b) {
	return a * b;
}


// hello.cpp:

int multiply(int a, int b);

int main() {
	multiply(3, 4);
}
```

- При компиляции `hello.cpp` будет ошибка
```bash
collect2: error: ld returned 1 exit status
```
- `collect2` - обертка над `ld`

```bash
g++ -shared mylib.cpp -o mylib.so
```
- Это либа, по `ldd` видно, что там есть раздел `.dynsym`, где перечислены функции, которые публично видны (но из индексируемого там только multiply)

- Теперь скомпилируем с библиотекой
	- Вообще все библиотеки должны начинаться с `lib` (EX: `libc.so`, `libmylib.so`)
	- Поэтому нужно переименовать на `libmylib.so` и перенести в `/usr/lib` (локально он её не найдет) (или дописать `-L.`, типа libraries in `.` (there!))
```bash
g++ -lmylib hello.cpp
```

- Скомпилируем с вариантом, где либа находится в той же папке, посмотрим в `ldd`
	- Там `libmylib.so => not found`
- Мы также не сможем запустить

- Фактически, дело обстоит так: при компиляции мы попросили компилятор скомпилировать прогу вместе с `libmylib.so`
- Однако компилятор не вписал в программу путь, где эту либу при запуске искать
- Что надо сделать? Есть 3 варианта;
	1) Через переменную окружения (`LD_PRELOAD`)
	2) Через `LD_LIBRARY_PATH=. ./a.out`
	3) Адекватно: указать программе, где искать её зависимость

- Про последнее:
- Добавить при линковке дописать `-Wl,-rpath=dir`
	- У `g++` флага `-rpath` нет, `-Wl` говорит g++, что флаг надо передать линковщику
	- Он запишет адрес прямо в ELF-файл программы

# ltrace

- Есть полезная тулза `ltace`, которая регулирует все библиотечные вызовы
	- Пишет в `stderr`, что логично (вообще все логи выводятся в `stderr`, отдельно от основного вывода)

- С флагом `-C` выведет неманглированные имена
```bash
ltrace -C ./a.out 2>2.txt
```

- По факту, подменяет стандартный динамический линковщий на тот, что логирует дополнительно

# Больше про `.so`

Помимо `.dynsym`, есть `SECTION HEADER`, где указаны `.data`, `.text`, `.bss`

- `.data`, `.bss`, `.rodata` - статические данные (глобальные переменные и тп)
	- `.rodata` - Read Only Data - константы (там же `const char*`))
		- Зачем разделять? Права доступа к памяти
	- `.data` - Статические данные, данные для инициализации которых заготовлены и лежат в коде программы 
	- `.bss` - То, что нужно проинициализировать при запуске, но по факту не проинициализированные (например, массив из 1'000'000 `int`'ов изначально заполнен нулями) ==TODO== Ctrl+C from cpp_cource_notes
- `.text` - текст программы (испольняемый код)

- `symtab` - таблица символов
	- Символ (с точки зрения линковщика) - это сущности, которые потенциально могут иметь адреса (переменные, фунции...)
		- Линковщик работает с символами и ТОЛЬКО с ними
	- Bind (связывания): LOCAL (видны в пределах единицы трансляции (например, `static int x = 5;` в Global scope)), GLOBAL ("торчат" из файла, те видны всем), WEAK (если линковщик видит несколько определений одной сущности, то он выберет слабое ==TODO== или сильное. Пример; `new`, `delete`, ...)
```cpp
// mylib.cpp:
int __attribute__((weak)) a = 3;  // аттрибут для линковщика

// main.cpp:
int a = 4;
```

-  Vis (visibility, видимость): HIDDEN (), DEFAULT ()
==TODO== check example and research MORE (example is AI generated!)

- `dynsym` - символы, которые подлежат динамической линковке

# Core file

- Четверный вид ELF-файла

- Есть дебаггер (gdb)
```bash
g++ -g main.cpp
```
- Размер значительно возрастет: добавяться debug-символы

```bash
gdb a.out

(gdb) b mergesort.cpp:26  # breakpoint
(gdb) bt  # backtrace
(gdb) cont  # continue
(gdb) n
(gdb) s
(gdb) q
(gdb) p
(gdb) watch arr+6
```

# Core dumped
- Segmentation fault (Core dumped)

- Core Dumped - память сдамплена и сохранена в файл
`/var/lib/apport/coredump`

==TODO== научиться смотреть Core Dump файлы. Будет на экзе!

- Если посмотреть, то его тип - Core File
	- Это файл, который содержит снимок программы на момент падения
	- Этот файл можно читать с помощью `gdb`

```bash
gdb -c core_dump
```
- Выведет без символов

- А можно указать программу
	- Тогда `gdb` покажет строки, где программа упала
```bash
gdb -c core_dump a.out
```
